# PopupChatKit 开发文档

## 项目信息

- **项目名称**: PopupChatKit
- **版本**: v1.0.0
- **创建日期**: 2025-10-28
- **技术负责人**: Colin

---

## 技术架构

### 整体架构

```
┌─────────────────────────────────────────┐
│           Frontend (HTML5 + JS)         │
│  ┌─────────────┐  ┌──────────────────┐  │
│  │  Standalone │  │  Embedded Mode   │  │
│  │    Mode     │  │  (popup.js)      │  │
│  └──────┬──────┘  └────────┬─────────┘  │
│         │                  │            │
└─────────┼──────────────────┼────────────┘
          │                  │
          └────────┬─────────┘
                   │ HTTP/WS
          ┌────────▼─────────┐
          │  FastAPI Server  │
          │   (Python)       │
          ├──────────────────┤
          │  pydantic-ai     │
          │  ┌─────┐ ┌─────┐ │
          │  │ GLM │ │Qwen │ │
          │  └─────┘ └─────┘ │
          └────────┬─────────┘
                   │
          ┌────────▼─────────┐
          │  SQLite Database │
          └──────────────────┘
```

---

## 技术选型说明

### 前端技术

#### HTML5
- 语义化标签提升可访问性
- 原生功能,无依赖,加载快速
- 适合嵌入式场景

#### Vanilla JavaScript
- **选择原因**: 
  - 无框架依赖,打包体积小
  - 适合嵌入其他网站,避免冲突
  - 性能优秀,启动快速
- **模块化**: 使用 ES6 模块化
- **兼容性**: 支持现代浏览器 (Chrome 90+, Firefox 88+, Safari 14+)

#### CSS3
- **样式隔离**: 嵌入模式使用 Shadow DOM
- **响应式**: Flexbox + Grid 布局
- **主题系统**: CSS Variables 实现主题切换

### 后端技术

#### FastAPI
- **异步支持**: 原生 async/await
- **类型安全**: Pydantic 模型验证
- **自动文档**: OpenAPI/Swagger
- **性能优秀**: 基于 Starlette 和 Uvicorn

#### pydantic-ai
- **统一接口**: 抽象不同 LLM 提供商
- **类型安全**: 强类型支持
- **流式输出**: 支持 SSE 流式响应
- **消息历史**: 内置对话历史管理

#### SQLite
- **零配置**: 无需独立数据库服务
- **轻量级**: 适合个人和小型项目
- **可靠性**: 事务支持,数据持久化
- **可移植**: 单文件数据库

---

## 项目结构

```
PopupChatKit/
├── backend/                    # 后端代码
│   ├── main.py                # FastAPI 主应用
│   ├── database.py            # 数据库操作
│   ├── models.py              # Pydantic 模型
│   ├── agents.py              # AI Agent 配置
│   ├── routers/               # API 路由
│   │   ├── chat.py           # 对话相关 API
│   │   ├── draw.py           # 绘画相关 API
│   │   ├── history.py        # 历史记录 API
│   │   └── config.py         # 配置管理 API
│   ├── utils/                 # 工具函数
│   │   ├── web_extractor.py  # 网页内容提取
│   │   └── image_handler.py  # 图片处理
│   ├── init_db.sql            # 数据库初始化 SQL
│   └── pyproject.toml         # 项目依赖配置
│
├── frontend/                   # 前端代码
│   ├── standalone/            # 独立模式
│   │   ├── index.html        # 首页/配置页
│   │   ├── chat.html         # 对话页面
│   │   ├── history.html      # 历史记录页
│   │   ├── draw.html         # 绘画页面
│   │   ├── settings.html     # 设置页面
│   │   ├── about.html        # 关于页面
│   │   ├── css/
│   │   │   ├── common.css    # 公共样式
│   │   │   ├── chat.css      # 对话页面样式
│   │   │   └── theme.css     # 主题变量
│   │   └── js/
│   │       ├── api.js        # API 调用封装
│   │       ├── chat.js       # 对话逻辑
│   │       ├── history.js    # 历史记录逻辑
│   │       ├── config.js     # 配置管理
│   │       └── utils.js      # 工具函数
│   │
│   ├── embedded/              # 嵌入模式
│   │   ├── popup.js          # 嵌入脚本 (核心)
│   │   ├── popup.css         # 弹窗样式
│   │   └── demo.html         # 演示页面
│   │
│   └── lib/                   # 第三方库
│       ├── markdown-it.min.js
│       └── highlight.min.js
│
├── ai-chat-ui/                # UI 原型和文档
│   ├── 功能点梳理.md
│   ├── 开发文档.md
│   └── index.html            # UI 原型展示
│
├── data/                      # 数据文件
│   └── chat.db               # SQLite 数据库
│
└── README.md                  # 项目说明
```

---

## 数据库设计

### DDL 语句

```sql
-- 初始化数据库脚本
-- 文件位置: backend/init_db.sql

-- 会话表
CREATE TABLE IF NOT EXISTS sessions (
    id TEXT PRIMARY KEY,              -- UUID 格式的会话 ID
    title TEXT NOT NULL,              -- 会话标题
    mode TEXT DEFAULT 'standalone',   -- 模式: standalone/embedded
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_created ON sessions(created_at DESC);

-- 消息表
CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL,         -- 关联会话 ID
    message_list TEXT NOT NULL,       -- JSON 格式的消息列表
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

CREATE INDEX idx_messages_session ON messages(session_id);
CREATE INDEX idx_messages_created ON messages(created_at DESC);

-- 用户配置表
CREATE TABLE IF NOT EXISTS user_config (
    key TEXT PRIMARY KEY,             -- 配置键
    value TEXT NOT NULL,              -- 配置值 (加密存储)
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 绘画历史表
CREATE TABLE IF NOT EXISTS draw_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    prompt TEXT NOT NULL,             -- 绘画提示词
    negative_prompt TEXT,             -- 负面提示词
    image_url TEXT NOT NULL,          -- 图片 URL
    model TEXT,                       -- 使用的模型
    parameters TEXT,                  -- JSON 格式的参数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_draw_created ON draw_history(created_at DESC);

-- 网页分析缓存表 (可选)
CREATE TABLE IF NOT EXISTS web_cache (
    url TEXT PRIMARY KEY,             -- 网页 URL
    content TEXT NOT NULL,            -- 提取的内容
    summary TEXT,                     -- AI 总结
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP              -- 过期时间
);

CREATE INDEX idx_web_cache_expires ON web_cache(expires_at);
```

### 数据库操作封装

```python
# backend/database.py

import asyncio
import json
import sqlite3
from collections.abc import AsyncIterator, Callable
from concurrent.futures.thread import ThreadPoolExecutor
from contextlib import asynccontextmanager
from dataclasses import dataclass
from functools import partial
from pathlib import Path
from typing import Any, TypeVar

from pydantic_ai import ModelMessage, ModelMessagesTypeAdapter
from typing_extensions import LiteralString, ParamSpec

P = ParamSpec('P')
R = TypeVar('R')

@dataclass
class Database:
    """数据库操作类"""
    
    con: sqlite3.Connection
    _loop: asyncio.AbstractEventLoop
    _executor: ThreadPoolExecutor

    @classmethod
    @asynccontextmanager
    async def connect(cls, file: Path) -> AsyncIterator['Database']:
        """连接数据库"""
        loop = asyncio.get_event_loop()
        executor = ThreadPoolExecutor(max_workers=1)
        con = await loop.run_in_executor(executor, cls._connect, file)
        slf = cls(con, loop, executor)
        try:
            yield slf
        finally:
            await slf._asyncify(con.close)

    @staticmethod
    def _connect(file: Path) -> sqlite3.Connection:
        """建立数据库连接并初始化"""
        con = sqlite3.connect(str(file))
        # 读取 init_db.sql 并执行
        init_sql = (Path(__file__).parent / 'init_db.sql').read_text()
        con.executescript(init_sql)
        con.commit()
        return con

    async def add_messages(self, session_id: str, messages: bytes):
        """添加消息到数据库"""
        await self._asyncify(
            self._execute,
            'INSERT INTO messages (session_id, message_list) VALUES (?, ?);',
            session_id, messages,
            commit=True
        )

    async def get_messages(self, session_id: str) -> list[ModelMessage]:
        """获取会话的所有消息"""
        c = await self._asyncify(
            self._execute, 
            'SELECT message_list FROM messages WHERE session_id = ? ORDER BY id',
            session_id
        )
        rows = await self._asyncify(c.fetchall)
        messages: list[ModelMessage] = []
        for row in rows:
            messages.extend(ModelMessagesTypeAdapter.validate_json(row[0]))
        return messages

    async def create_session(self, session_id: str, title: str, mode: str = 'standalone'):
        """创建新会话"""
        await self._asyncify(
            self._execute,
            'INSERT INTO sessions (id, title, mode) VALUES (?, ?, ?);',
            session_id, title, mode,
            commit=True
        )

    async def get_sessions(self, limit: int = 50) -> list[dict]:
        """获取会话列表"""
        c = await self._asyncify(
            self._execute,
            'SELECT id, title, mode, created_at, updated_at FROM sessions ORDER BY updated_at DESC LIMIT ?',
            limit
        )
        rows = await self._asyncify(c.fetchall)
        return [
            {
                'id': row[0],
                'title': row[1],
                'mode': row[2],
                'created_at': row[3],
                'updated_at': row[4]
            }
            for row in rows
        ]

    async def update_session(self, session_id: str, title: str = None):
        """更新会话信息"""
        if title:
            await self._asyncify(
                self._execute,
                'UPDATE sessions SET title = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                title, session_id,
                commit=True
            )
        else:
            await self._asyncify(
                self._execute,
                'UPDATE sessions SET updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                session_id,
                commit=True
            )

    async def delete_session(self, session_id: str):
        """删除会话及其消息"""
        await self._asyncify(
            self._execute,
            'DELETE FROM sessions WHERE id = ?',
            session_id,
            commit=True
        )

    async def save_config(self, key: str, value: str):
        """保存配置"""
        await self._asyncify(
            self._execute,
            'INSERT OR REPLACE INTO user_config (key, value) VALUES (?, ?)',
            key, value,
            commit=True
        )

    async def get_config(self, key: str) -> str | None:
        """获取配置"""
        c = await self._asyncify(
            self._execute,
            'SELECT value FROM user_config WHERE key = ?',
            key
        )
        row = await self._asyncify(c.fetchone)
        return row[0] if row else None

    def _execute(
        self, sql: LiteralString, *args: Any, commit: bool = False
    ) -> sqlite3.Cursor:
        """执行 SQL"""
        cur = self.con.cursor()
        cur.execute(sql, args)
        if commit:
            self.con.commit()
        return cur

    async def _asyncify(
        self, func: Callable[P, R], *args: P.args, **kwargs: P.kwargs
    ) -> R:
        """异步执行同步函数"""
        return await self._loop.run_in_executor(
            self._executor,
            partial(func, **kwargs),
            *args,
        )
```

---

## API 设计

### RESTful API 接口

#### 1. 对话相关

```
POST   /api/chat/message          # 发送消息
GET    /api/chat/history          # 获取历史消息
POST   /api/chat/stream           # 流式对话
DELETE /api/chat/session/{id}    # 删除会话
```

#### 2. 会话管理

```
GET    /api/sessions              # 获取会话列表
POST   /api/sessions              # 创建会话
PUT    /api/sessions/{id}         # 更新会话
DELETE /api/sessions/{id}         # 删除会话
```

#### 3. 配置管理

```
GET    /api/config                # 获取配置
POST   /api/config                # 保存配置
POST   /api/config/validate       # 验证 API Key
```

#### 4. 网页分析

```
POST   /api/web/extract           # 提取网页内容
POST   /api/web/summarize         # 总结网页
POST   /api/web/to-json           # 转换为 JSON
```

#### 5. 图片相关

```
POST   /api/image/upload          # 上传图片
POST   /api/image/analyze         # 分析图片
POST   /api/draw                  # AI 绘画
GET    /api/draw/history          # 绘画历史
```

### API 详细设计

#### POST /api/chat/stream

**请求体:**
```json
{
  "session_id": "uuid-string",
  "message": "用户消息内容",
  "model": "zhipu",  // zhipu | qwen
  "stream": true
}
```

**响应:** Server-Sent Events (SSE)
```
data: {"type": "start", "timestamp": "2025-10-28T10:00:00Z"}

data: {"type": "content", "content": "AI 回复内容片段"}

data: {"type": "content", "content": "更多内容"}

data: {"type": "end", "timestamp": "2025-10-28T10:00:05Z"}
```

#### POST /api/web/extract

**请求体:**
```json
{
  "url": "https://example.com",
  "mode": "text"  // text | markdown | json
}
```

**响应:**
```json
{
  "url": "https://example.com",
  "title": "网页标题",
  "content": "提取的内容",
  "metadata": {
    "description": "网页描述",
    "keywords": ["关键词1", "关键词2"]
  }
}
```

---

## 前端开发指南

### 独立模式实现

#### 对话页面 (chat.html)

**核心功能:**
1. 消息列表展示
2. 输入框和发送按钮
3. 流式响应显示
4. Markdown 渲染
5. 代码高亮

**关键代码:**

```javascript
// frontend/standalone/js/chat.js

class ChatApp {
  constructor(sessionId) {
    this.sessionId = sessionId;
    this.apiBase = '/api';
  }

  async sendMessage(message) {
    // 添加用户消息到 UI
    this.addMessage('user', message);

    // 创建 AI 消息占位符
    const aiMsgId = this.addMessage('assistant', '');

    try {
      const response = await fetch(`${this.apiBase}/chat/stream`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          session_id: this.sessionId,
          message: message,
          stream: true
        })
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const {done, value} = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, {stream: true});
        const lines = buffer.split('\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            if (data.type === 'content') {
              this.updateMessage(aiMsgId, data.content);
            }
          }
        }
      }
    } catch (error) {
      console.error('发送消息失败:', error);
      this.showError('发送失败,请重试');
    }
  }

  addMessage(role, content) {
    // 添加消息到 DOM
    const msgEl = document.createElement('div');
    msgEl.className = `message message-${role}`;
    msgEl.innerHTML = this.renderMarkdown(content);
    document.querySelector('.message-list').appendChild(msgEl);
    return msgEl.id;
  }

  updateMessage(id, content) {
    // 更新消息内容
    const msgEl = document.getElementById(id);
    msgEl.innerHTML = this.renderMarkdown(content);
  }

  renderMarkdown(text) {
    // 使用 markdown-it 渲染
    return window.markdownit().render(text);
  }
}
```

### 嵌入模式实现

#### 核心脚本 (popup.js)

**功能特点:**
1. 单文件实现
2. Shadow DOM 样式隔离
3. 最小化依赖
4. 灵活配置

**集成方式:**

```html
<!-- 在目标网站中添加 -->
<script src="https://your-domain.com/popup.js"></script>
<script>
  PopupChat.init({
    apiKey: 'your-api-key',
    model: 'zhipu',
    position: 'right',  // right | left
    theme: 'light'      // light | dark
  });
</script>
```

**核心代码结构:**

```javascript
// frontend/embedded/popup.js

(function() {
  'use strict';

  class PopupChat {
    constructor(config) {
      this.config = config;
      this.isOpen = false;
      this.init();
    }

    init() {
      // 创建 Shadow DOM
      this.container = document.createElement('div');
      this.container.id = 'popup-chat-container';
      document.body.appendChild(this.container);

      const shadow = this.container.attachShadow({mode: 'open'});
      
      // 注入样式
      const style = document.createElement('style');
      style.textContent = this.getStyles();
      shadow.appendChild(style);

      // 创建 UI
      this.createUI(shadow);
      
      // 绑定事件
      this.bindEvents();
    }

    createUI(shadow) {
      const html = `
        <div class="popup-chat">
          <button class="popup-trigger">💬</button>
          <div class="popup-panel" style="display: none;">
            <div class="popup-header">
              <h3>AI 助手</h3>
              <div class="popup-actions">
                <button class="btn-summarize" title="总结页面">📄</button>
                <button class="btn-screenshot" title="截图分析">📷</button>
                <button class="btn-close">✕</button>
              </div>
            </div>
            <div class="popup-body">
              <div class="message-list"></div>
            </div>
            <div class="popup-footer">
              <textarea placeholder="输入消息..." rows="2"></textarea>
              <button class="btn-send">发送</button>
            </div>
          </div>
        </div>
      `;
      
      const wrapper = document.createElement('div');
      wrapper.innerHTML = html;
      shadow.appendChild(wrapper);
    }

    async summarizePage() {
      // 提取当前页面内容
      const content = this.extractPageContent();
      
      // 调用 API 总结
      const summary = await this.callAPI('/api/web/summarize', {
        content: content,
        url: window.location.href
      });
      
      // 显示结果
      this.addMessage('assistant', summary);
    }

    extractPageContent() {
      // 提取页面主要内容
      const title = document.title;
      const main = document.querySelector('main, article, .content, #content');
      const text = main ? main.innerText : document.body.innerText;
      
      return {
        title: title,
        text: text.slice(0, 5000),  // 限制长度
        url: window.location.href
      };
    }

    async captureScreenshot() {
      // 使用 html2canvas 或 浏览器 API 截图
      // 这里简化处理
      alert('截图功能开发中');
    }

    getStyles() {
      return `
        .popup-chat {
          position: fixed;
          right: 20px;
          bottom: 20px;
          z-index: 999999;
        }
        
        .popup-trigger {
          width: 60px;
          height: 60px;
          border-radius: 50%;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border: none;
          color: white;
          font-size: 24px;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          transition: transform 0.2s;
        }
        
        .popup-trigger:hover {
          transform: scale(1.1);
        }
        
        .popup-panel {
          position: absolute;
          right: 0;
          bottom: 80px;
          width: 400px;
          height: 600px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.2);
          display: flex;
          flex-direction: column;
        }
        
        .popup-header {
          padding: 16px;
          border-bottom: 1px solid #e5e7eb;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        
        .popup-body {
          flex: 1;
          overflow-y: auto;
          padding: 16px;
        }
        
        .popup-footer {
          padding: 16px;
          border-top: 1px solid #e5e7eb;
          display: flex;
          gap: 8px;
        }
        
        .popup-footer textarea {
          flex: 1;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
          padding: 8px;
          resize: none;
        }
        
        .btn-send {
          padding: 8px 16px;
          background: #667eea;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
        }
      `;
    }
  }

  // 全局暴露
  window.PopupChat = {
    init: (config) => new PopupChat(config)
  };
})();
```

---

## 后端开发指南

### FastAPI 主应用

```python
# backend/main.py

from pathlib import Path
from contextlib import asynccontextmanager

import fastapi
from fastapi import Request
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from .database import Database
from .routers import chat, history, config, web, draw

THIS_DIR = Path(__file__).parent
FRONTEND_DIR = THIS_DIR.parent / 'frontend'
DATA_DIR = THIS_DIR.parent / 'data'
DB_FILE = DATA_DIR / 'chat.db'

# 确保数据目录存在
DATA_DIR.mkdir(exist_ok=True)


@asynccontextmanager
async def lifespan(_app: fastapi.FastAPI):
    """应用生命周期管理"""
    async with Database.connect(DB_FILE) as db:
        yield {'db': db}


app = fastapi.FastAPI(
    title="PopupChatKit API",
    description="AI 对话与网页分析服务",
    version="1.0.0",
    lifespan=lifespan
)

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(chat.router, prefix="/api/chat", tags=["对话"])
app.include_router(history.router, prefix="/api/sessions", tags=["会话"])
app.include_router(config.router, prefix="/api/config", tags=["配置"])
app.include_router(web.router, prefix="/api/web", tags=["网页分析"])
app.include_router(draw.router, prefix="/api/draw", tags=["绘画"])

# 静态文件服务
app.mount("/static", StaticFiles(directory=FRONTEND_DIR), name="static")


@app.get("/")
async def root():
    """返回独立模式首页"""
    return FileResponse(FRONTEND_DIR / 'standalone' / 'index.html')


@app.get("/popup.js")
async def popup_script():
    """返回嵌入式脚本"""
    return FileResponse(
        FRONTEND_DIR / 'embedded' / 'popup.js',
        media_type='application/javascript'
    )


async def get_db(request: Request) -> Database:
    """依赖注入: 获取数据库连接"""
    return request.state.db


if __name__ == '__main__':
    import uvicorn
    uvicorn.run(
        'backend.main:app',
        host='0.0.0.0',
        port=8000,
        reload=True
    )
```

### AI Agent 配置

```python
# backend/agents.py

from pydantic_ai import Agent
from typing import Literal

# 智谱 AI Agent
zhipu_agent = Agent(
    'zhipu:glm-4',  # 模型名称
    system_prompt="""你是一个友好、专业的 AI 助手。
    
你的职责:
1. 准确理解用户意图,提供有价值的回答
2. 以简洁清晰的方式表达,必要时使用 Markdown 格式
3. 对于代码相关问题,提供完整可运行的示例
4. 遇到不确定的信息,诚实告知而非臆测

你的特点:
- 友好但不过度热情
- 专业但不生硬
- 简洁但不省略关键信息
"""
)

# 通义千问 Agent
qwen_agent = Agent(
    'qwen:qwen-turbo',
    system_prompt="""你是一个友好、专业的 AI 助手。
    
你的职责:
1. 准确理解用户意图,提供有价值的回答
2. 以简洁清晰的方式表达,必要时使用 Markdown 格式
3. 对于代码相关问题,提供完整可运行的示例
4. 遇到不确定的信息,诚实告知而非臆测

你的特点:
- 友好但不过度热情
- 专业但不生硬
- 简洁但不省略关键信息
"""
)


def get_agent(model: Literal['zhipu', 'qwen'] = 'zhipu') -> Agent:
    """根据模型名称获取 Agent"""
    if model == 'qwen':
        return qwen_agent
    return zhipu_agent
```

### 对话路由实现

```python
# backend/routers/chat.py

import json
from datetime import datetime, timezone
from typing import Annotated

from fastapi import APIRouter, Depends, Form
from fastapi.responses import StreamingResponse

from ..database import Database
from ..agents import get_agent
from ..models import ChatMessage, ChatRequest

router = APIRouter()


async def get_db() -> Database:
    """获取数据库连接 (简化版,实际从 request.state 获取)"""
    pass  # 实际实现见 main.py


@router.post('/stream')
async def chat_stream(
    request: ChatRequest,
    database: Database = Depends(get_db)
) -> StreamingResponse:
    """流式对话接口"""
    
    async def stream_messages():
        # 发送用户消息
        yield json.dumps({
            'type': 'start',
            'timestamp': datetime.now(tz=timezone.utc).isoformat()
        }).encode('utf-8') + b'\n'
        
        # 获取历史消息
        messages = await database.get_messages(request.session_id)
        
        # 选择 Agent
        agent = get_agent(request.model)
        
        # 运行 Agent
        async with agent.run_stream(
            request.message,
            message_history=messages
        ) as result:
            async for text in result.stream_output(debounce_by=0.01):
                yield json.dumps({
                    'type': 'content',
                    'content': text
                }).encode('utf-8') + b'\n'
        
        # 保存新消息
        await database.add_messages(
            request.session_id,
            result.new_messages_json()
        )
        
        # 更新会话时间
        await database.update_session(request.session_id)
        
        # 发送结束标记
        yield json.dumps({
            'type': 'end',
            'timestamp': datetime.now(tz=timezone.utc).isoformat()
        }).encode('utf-8') + b'\n'
    
    return StreamingResponse(
        stream_messages(),
        media_type='text/plain'
    )


@router.get('/history/{session_id}')
async def get_history(
    session_id: str,
    database: Database = Depends(get_db)
):
    """获取对话历史"""
    messages = await database.get_messages(session_id)
    return {'session_id': session_id, 'messages': messages}
```

---

## 部署指南

### 开发环境

```bash
# 1. 克隆项目
git clone https://github.com/your-name/PopupChatKit.git
cd PopupChatKit

# 2. 安装 uv (如果未安装)
curl -LsSf https://astral.sh/uv/install.sh | sh

# 3. 安装依赖
cd backend
uv sync

# 4. 配置环境变量
cp .env.example .env
# 编辑 .env 文件,填入 API Keys

# 5. 启动开发服务器
uv run python -m backend.main

# 6. 访问
# http://localhost:8000
```

### 生产环境

```bash
# 使用 Docker 部署
docker build -t popupchatkit .
docker run -d -p 8000:8000 \
  -v $(pwd)/data:/app/data \
  -e ZHIPU_API_KEY=your_key \
  -e QWEN_API_KEY=your_key \
  popupchatkit
```

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装 uv
RUN pip install uv

# 复制项目文件
COPY backend/ ./backend/
COPY frontend/ ./frontend/
COPY pyproject.toml .

# 安装依赖
RUN uv sync --no-dev

# 暴露端口
EXPOSE 8000

# 启动应用
CMD ["uv", "run", "python", "-m", "backend.main"]
```

---

## 测试策略

### 单元测试

```python
# tests/test_database.py

import pytest
from backend.database import Database

@pytest.mark.asyncio
async def test_add_and_get_messages():
    async with Database.connect(':memory:') as db:
        session_id = 'test-session'
        await db.create_session(session_id, '测试会话')
        
        # 添加消息
        messages = [...]  # ModelMessage 列表
        await db.add_messages(session_id, json.dumps(messages).encode())
        
        # 获取消息
        retrieved = await db.get_messages(session_id)
        assert len(retrieved) == len(messages)
```

### 集成测试

```python
# tests/test_api.py

from fastapi.testclient import TestClient
from backend.main import app

client = TestClient(app)

def test_chat_stream():
    response = client.post(
        '/api/chat/stream',
        json={
            'session_id': 'test',
            'message': '你好',
            'model': 'zhipu',
            'stream': True
        }
    )
    assert response.status_code == 200
```

---

## 性能优化

### 1. 数据库优化
- 使用索引加速查询
- 定期清理过期数据
- 考虑使用连接池

### 2. 缓存策略
- 静态资源使用 CDN
- API 响应使用 Redis 缓存
- 网页提取结果缓存

### 3. 前端优化
- 代码分割和懒加载
- 图片懒加载和压缩
- 使用 Web Workers 处理大数据

---

## 安全考虑

### 1. API Key 安全
- 后端存储时加密
- 传输使用 HTTPS
- 支持环境变量配置

### 2. XSS 防护
- 用户输入严格过滤
- Markdown 渲染使用白名单
- CSP 策略配置

### 3. CSRF 防护
- 使用 Token 验证
- 检查 Referer 头
- SameSite Cookie

### 4. 速率限制
- API 调用频率限制
- IP 黑名单机制
- 用量监控告警

---

## 常见问题

### Q1: 如何切换 LLM 模型?
A: 在配置页面或 API 请求中指定 `model` 参数为 `zhipu` 或 `qwen`。

### Q2: 嵌入模式如何避免样式冲突?
A: 使用 Shadow DOM 实现样式隔离,确保不影响宿主页面。

### Q3: 数据库文件存储在哪里?
A: 默认存储在 `data/chat.db`,可通过环境变量 `DB_PATH` 配置。

### Q4: 如何备份对话历史?
A: 直接备份 `data/chat.db` 文件,或使用 API 导出为 JSON。

---

## 参考资料

- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [pydantic-ai 文档](https://ai.pydantic.dev/)
- [智谱 AI API 文档](https://open.bigmodel.cn/dev/api)
- [通义千问 API 文档](https://help.aliyun.com/zh/dashscope/)
- [MDN Web Docs](https://developer.mozilla.org/)

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-28  
**维护者**: Colin
